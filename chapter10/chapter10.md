### chapter 10 结构和联合

#### 结构体基本概念

1. 结构变量属于**标量**（函数传参为传值）

2. 结构变量的访问是通过操作符(.)来进行的。

3. 使用typedef创建结构。（给出example）

   ```c
   struct Simple{
       int a;
       char b;
       float c;
   };
   ```

   使用typedef：

   ```c
   struct{
       int a;
       char b;
       float c;
   }Simple;
   ```

4. 下标引用和点操作符具有相同的优先级，结合性都是从左向右的。

5. 结构体的间接访问：

   （1）通过指针间接访问结构（2）通过点操作符访问结构的成员

   例子：`(*cp).f`，使用cp指针访问结构然后使用点操作符访问成员f

6. 使用箭头操作符直接对结构成员进行间接访问。

   箭头操作符接受两个操作数：左操作数：必须是一个指向结构的指针，右操作数：选择一个需要访问的结构成员。

7. 结构的自引用：

   结构内部包含一个指向该结构体本身的指针，这个指针实际上是指向的同一个类型的不同结构。（例如链表，树，通过自引用指向下一个结构或者元素分支）

8. 结构体的初始化类似于数组的初始化。

9. ->操作符的优先级高于&操作符的优先级

10. 运算符优先级方面：-> 大于 . 大于 *

#### 结构体的存储分配

1. 在结构体的声明中，对结构的成员进行重新的排列组合可以让那些对边界要求十分严格的成员首先出现，对边界条件要求最弱的最后出现，这种做法可以最大程度的减少因为对齐问题而带来的空间损失。

2. 使用`offsetof`宏可以确定一个结构的某个成员的实际位置（位于stddef.h头文件中），用法为：`offsetof(type,memeber)`

   其中type表示结构的类型，member表示的是这个结构中的某个成员。

3. 对于绝大多数结构体来说，进行函数调用时选择传递指针的效率会高于直接传递一个结构。

#### 课后习题

1. 成员和数组元素之间有什么区别？

   *成员的类型可以不同；我们通过成员的名字去访问成员；由于边界的对齐结构体在存储时存在内存损失*

   *数组元素的类型相同；通过数组下标去访问数组成员；不存在由于边界对齐而带来的内存损失*

2. 结构名和数组名的区别？

   *结构是一个标量，结构名作为左值时表示结构体存储在内存中的位置；结构名作为右值时表示的是存储在结构中的值。*

   *数组名是一个指针常量，只能够作为表达式右值，不能够作为表达式左值，不可以对其进行修改。*

3. （第七题）考虑下面的声明和数据：

   ```c
   struct NODE{
       int a;
       struct NODE *b;
       struct NODE *c;
   }
   ```

   ```c
   struct NODE nodes[5] = {
       {5 ,nodes+3, NULL},
       {15,nodes+4, nodes+3},
       {22,NULL,    nodes+4},
       {12,nodes+1, nodes},
       {18,nodes+2, nodes+1},
   };
   (other declarations)
   struct NODE *np = nodes+2;
   struct NODE **npp = &nodes[1].b;
   ```

   对下面的表达式求值，假设nodes数组在内存中的初始位置为200，并且在这台机器上整数和指针的长度都是4个字节。

   | 表达式         | 值                   |
   | -------------- | -------------------- |
   | nodes          | 200                  |
   | nodes.a        | **非法**             |
   | nodes[3].a     | 12                   |
   | nodes[3].c     | 200                  |
   | nodes[3].c->a  | 5                    |
   | *nodes         | {5,nodes+3,NULL}     |
   | *nodes.a       | **非法**             |
   | (*nodes).a     | 5                    |
   | nodes->a       | 5                    |
   | nodes[3].b->b  | 248                  |
   | *nodes[3].b->b | {18,nodes+2,nodes+1} |
   | &nodes         | 200                  |
   | &nodes[3].a    | 236                  |
   | &nodes[3].c    | **244**              |
   | &nodes[3].c->a | 200                  |
   | &nodes->a      | 200                  |
   | np             | 224                  |
   | np->a          | 22                   |
   | np->c->c->a    | 15                   |
   | npp            | **216**              |
   | npp->a         | **非法**             |
   | *npp           | **248**              |
   | **npp          | {18,nodes+2,nodes+1} |
   | *npp->a        | **非法**             |
   | (*npp)->a      | 18                   |
   | &np            | **非法**             |
   | &np->a         | 224                  |
   | &np->c->c->a   | 212                  |

   主要的问题出在对于npp这个二重指针的理解上，对于npp来说，npp的值就应该是表达式的右值，&nodes[1].b，而这个表达式的意思表示为nodes[1].b所存储的位置，就是216，而*npp表示的是对于216这个地址的解引用，216这个地址存的是一个指针，指针表达式为nodes+4，所以这个指针的值就是nodes+4的起始位置248，而对于**npp来说，这个 *npp的一个解引用，结果应该表示为刚刚的nodes+4这个指针所指向的东西，这是一个指向一个结构的指针，所以对其进行解引用的结果就是这个结构体，我们可以写为：{18,nodes+2,nodes+1}，另外一个关于表达式 *npp->a的问题，这个表达式之所以是非法的是因为箭头操作符优先级高于 *，所以这个表达式是非法的。

4. 至少说出两个位段为什么不可以移植的理由？

   （1）*分配内存是从左向右还是从右向左*

   （2）*字段是否太大而无法放入剩余的位中，可能穿单元边界也可能从下一单元开始*

   （3）*声明的类型是signed还是unsigned*

   （4）*单个区域最大值不同*

（PS：关于位段以及联合的一些概念暂时不太涉及，这里就不多赘述了，课后习题也基本没看……）
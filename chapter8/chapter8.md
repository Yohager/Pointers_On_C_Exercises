### chapter 8 数组

#### 一维数组和二维数组

数组名的值就是一个指针常量，这个指针常量指向的值为内存中数组的起始位置。

关于下标引用：`array[subscript]`等价于`*(array+(subscript))`

C语言中的下标引用和间接访问表达式是一样的。

关于指针和下标：假定这两种方法都是正确的，下标引用绝不会比指针更加有效率，但是指针间接访问有时候比下标更加有效率。

在C语言中，多维数组的元素存储顺序按照最右边的下标率先变化的原则，成为行主序（row major order）。

一维数组的数组名的值是一个指针常量，它的类型是“指向元素类型的指针”，多维数组的数组名表示的是“指向一个包含n个元素类型的数组的指针”。

指向数组的指针：

对于一维数组而言：

`int vector[10]`  =>  `int *vp=vector`

这样的声明是合法的，首先为一个整型的数组分配内存，并把vp声明为一个指向整型的指针，并初始化为指向vector数组的第一个元素。

对于多维数组而言：

`int matrix[3][10]`  =>  `int *mp=matrix`

这样的声明是非法的，它正确的创建了matrix数组，并把mp定义为一个指向整型的指针，然而matrix不是一个指向整型的指针，而是一个指向整型数组的指针。

对于指向matrix的指针应该这样进行初始化：

`int (*mp)[10]=matrix`

mp表示为一个指向matrix第一行的指针

#### 指针数组

`int *api[10]`

这个表达式表示的就是声明了一个由指针组成的数组。（下标引用的优先级高于间接访问）

#### 课后习题

1. 根据下面给出的声明和数据，对每个表达式进行求值并写出其值，假定ints数组在内存中的起始位置是100，整型值和指针的长度都是4个字节。

   ```c
   int ints[20]={
         10,20,30,40,50,60,70,80,90,100,
         110,120,130,140,150,160,170,180,190,200
   };
   (other declarations)
   int *ip = ints + 3;
   ```

   | 表达式    | 值       | 表达式  | 值       |
   | --------- | -------- | ------- | -------- |
   | ints      | 100      | ip      | 112      |
   | ints[4]   | 50       | ip[4]   | **80**   |
   | ints+4    | 116      | ip+4    | **128**  |
   | *ints+4   | 14       | *ip+4   | 44       |
   | *(ints+4) | 50       | *(ip+4) | **80**   |
   | ints[-2]  | 非法     | ip[-2]  | 20       |
   | &ints     | 100      | &ip     | **未知** |
   | &ints[4]  | 116      | &ip[4]  | **128**  |
   | &ints+4   | 116      | &ip+4   | **未知** |
   | &ints[-2] | **非法** | &ip[-2] | 104      |

   对指针变量进行下标引用实际上相当于对指针变量进行间接访问，以ip[4]为例，ip这个指针本身是指向ints数组的第4个元素，ip[4]表示的是*(ip+4)，表示访问的是ints数组的第8个元素，即80.

2. 表达式`array[i+j]`和`i+j[array]`是否相等？

   不相等，`i+j[array]`等价于`array[j]+i`不等于`array[i+j]`

……后面的文字简答题写在课本上了，懒得打字了，编程题详见code

#### 编程题

第一题初始化数组没啥意思

第六题和第七题涉及可变参数列表暂时不做这个题

